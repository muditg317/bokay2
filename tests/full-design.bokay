// The program should compile once all features are implemented.

// imports:
//  import WholeLib, {oneMethod, SomeClass, anotherMethod} from "file/to/import.bokay"
//    should be similar to JS/TS style
//    extracts only certain symbols into the current context or all symbols under the WholeLib namespace
//    access with WholeLib::oneMethod(...)
import WholeLib, {oneMethod, SomeClass, anotherMethod} from "./export-stuff.bokay";

// types:
//  integers: (u|s)(8|16|32|64)   
//  floating: (f)(32|64)          -- no 128 because usually implemented in software anyways
//  arrays  : {base type} variable_name[{literal number}]

// declarations:
//  {type} {name};
//  {base type} variable_name[{literal number}]; // for arrays
//  {type} {name} = {expression of correct type};
a_byte: u8 = 5;
signed: s64 = -100;
a_float: f32 = -1234.4352;
bool the_boolean = false;
arr: u16[3]; // global space will default to 0'd out memory
arr[1] = 70531;

// special assignments:
//  C-style += -= *= /= etc

// special types:
//  structs : same as C
//    can't preinitialize
//    0 initialized
//  unions  : {base type} union {new_name} { [{type} {name};]... }
//    access unions with .
//    auto-assume base type of union if . not used - enables using as: u64 u16[4] or something
struct my_struct {
  unsigned16: u16;
  number: s32;
};
my_struct struct_var; // can't be initialized for now (defaults to 0 initialized)
struct_var.unsigned16 = 1452;
struct_var.number = -23441;
u64 union my_union {
  height: f32;
  chunks: u32[2];
  small_chunks: u16[4];
};
my_union union_var = 100; // simply has to be assignable to one of the components or the base type
a_number: u64 = union_var; // automatically assumes base type when not specified
big_float: f64 = union_var.height; // must specify which type to extract with since multiple options are assignable to f64
small_num: u32 = union_var.chunks[0]; // must specify which type to use when extracting value

// functions:
//  {return type} {function name}({type} {name} [= {default to be evaluated at each call}]) {
//    // contents
//  }
//  default params can be any where in the arg list (skip them via empty commas `func(5,,253)`)

u32 do_stuff(a: u16, b: u32) {
  return a+b;
}
res: u32 = do_stuff(5,6);

s64 weird_defaults(a: u16 = 5, b: u32, c: s16, d: s32 = -100, e: s64 = -8398, f: u8) {
  return a+b+c+d+e+f;
}
weird: s64 = weird_defaults(,5,-10,,-234,20); // runs with abcdef==5,5,-10,-100,-234,20 -- returns -314

// if conditionals:
//  if ({condition}) {
//    // code...
//  }
if (weird == -314) { // checks value equals, for structs, will iterate using == over entries
  cond_var: u8 = 0;
}
weird2: s64 = weird;
if (weird === weird2) { // checks pointer equals (similar to JS)
  cond_var: u8 = 0;
}

// while loops:
//  while ({condition}) {
//    // code...
//  }
while (weird < -300) {
  weird += 1;
}


// Comments:
//  The following comments should be handled.
//  The result should be `newVar: u8 = 2345;` and `big_float: f64 = 345.3245;`

/* a simple comment */
/* also /* a comment */
/* a comment * with a silly character in it */
/* a multi-line
  comment
*/
/* two comments on one line */ newVar: u8 = 2345; /* NOT one long comment */
/* a comment with a silly character at the end **/

big_float /* annoying comment */: f64 =/*kwfklre
*/ 345.2345 /*rehehtr*/ ; // annoyingly commented